<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/75.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/75.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/75.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/75.jpg?v=5.1.4" color="#222">





  <meta name="keywords" content="iOS,design pattern," />










<meta name="description" content="当我们谈论设计模式的时候，我们在谈什么？设计模式是为特定场景下的问题而定制的解决方案，是对特定面向对象设计问题主要方面的一种抽象。程序如果在设计中使用了设计模式，将来就更易于复用和扩展、且易于变更。另外，基于设计模式的程序会更加简洁和高效，因为达成同样目的所需的代码会更少。 最早对设计模式做出权威性论述和分类的是 Design Patterns: Elements of Reusable Obje">
<meta name="keywords" content="iOS,design pattern">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS 设计模式漫谈">
<meta property="og:url" content="http://yzlyty.github.io/2017/12/04/iOS-design-pattern/index.html">
<meta property="og:site_name" content="子轶的随想地">
<meta property="og:description" content="当我们谈论设计模式的时候，我们在谈什么？设计模式是为特定场景下的问题而定制的解决方案，是对特定面向对象设计问题主要方面的一种抽象。程序如果在设计中使用了设计模式，将来就更易于复用和扩展、且易于变更。另外，基于设计模式的程序会更加简洁和高效，因为达成同样目的所需的代码会更少。 最早对设计模式做出权威性论述和分类的是 Design Patterns: Elements of Reusable Obje">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/67dd7669gy1fmbu2o9asmj20em0iamz0.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/67dd7669gy1fm4zx66hhmj20hf0auwi4.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/67dd7669gy1fm4zwa3lghj20qz0d3q4g.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/67dd7669gy1fmbxvw55wbj20u60cntbt.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/67dd7669gy1fmby2fsfk2j20y10er44r.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/67dd7669gy1fmd3oc05bxj20n8084tb0.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/67dd7669gy1fmd44tr6e4j20pq07omyi.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/67dd7669gy1fmd4ewls47j21480h7wme.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/67dd7669gy1fmd4y54wx1j20cp07dwfl.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/67dd7669gy1fmjnpz0rk1j20yr0kx0xk.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/67dd7669gy1fmjqa3o9gxj20z00i2gqt.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/67dd7669gy1fmjqbgc17vj20pc0e0jt3.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/67dd7669gy1fmjrc7mhioj20w20do422.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/67dd7669gy1fmjrswakqlj20xx0e0wht.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/67dd7669gy1fmjs5uugz7j20n50eiwgk.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/67dd7669gy1fmjs7k65ppj20ux0ip0uv.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/67dd7669gy1fmjt9ffizlj211s0hyq6d.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/67dd7669gy1fmjty524n9j20yo0c7jv6.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/67dd7669gy1fmju6ps10ij20p70k1jw7.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/67dd7669gy1fmju8ky2rkj21340czwix.jpg">
<meta property="og:updated_time" content="2018-02-20T11:41:31.465Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS 设计模式漫谈">
<meta name="twitter:description" content="当我们谈论设计模式的时候，我们在谈什么？设计模式是为特定场景下的问题而定制的解决方案，是对特定面向对象设计问题主要方面的一种抽象。程序如果在设计中使用了设计模式，将来就更易于复用和扩展、且易于变更。另外，基于设计模式的程序会更加简洁和高效，因为达成同样目的所需的代码会更少。 最早对设计模式做出权威性论述和分类的是 Design Patterns: Elements of Reusable Obje">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/67dd7669gy1fmbu2o9asmj20em0iamz0.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yzlyty.github.io/2017/12/04/iOS-design-pattern/"/>





  <title>iOS 设计模式漫谈 | 子轶的随想地</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c7e856e0acd4db8def3a47b1435a89ed";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">子轶的随想地</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">但行好事，莫问前程</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yzlyty.github.io/2017/12/04/iOS-design-pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="子轶">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="子轶的随想地">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">iOS 设计模式漫谈</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-04T18:56:22+08:00">
                2017-12-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="当我们谈论设计模式的时候，我们在谈什么？"><a href="#当我们谈论设计模式的时候，我们在谈什么？" class="headerlink" title="当我们谈论设计模式的时候，我们在谈什么？"></a>当我们谈论设计模式的时候，我们在谈什么？</h2><p>设计模式是为特定场景下的问题而定制的解决方案，是对特定面向对象设计问题主要方面的一种抽象。程序如果在设计中使用了设计模式，将来就更易于复用和扩展、且易于变更。另外，基于设计模式的程序会更加简洁和高效，因为达成同样目的所需的代码会更少。</p>
<p>最早对设计模式做出权威性论述和分类的是 <a href="https://en.wikipedia.org/wiki/Design_Patterns" target="_blank" rel="noopener">Design Patterns: Elements of Reusable Object-Oriented Software</a>，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著，简称 Gang of Four (GoF)。书中论述了根据创建型（Creational）、结构型（Structural）、行为型（Behavioral）划分的一共 23 种设计模式。</p>
<a id="more"></a>
<p><img src="http://ww1.sinaimg.cn/large/67dd7669gy1fmbu2o9asmj20em0iamz0.jpg" alt=""></p>
<p>接下来会结合在 Cocoa Touch 中的应用来谈论一些常见的设计模式。</p>
<h2 id="MVC——设计模式之王"><a href="#MVC——设计模式之王" class="headerlink" title="MVC——设计模式之王"></a>MVC——设计模式之王</h2><p><img src="http://ww1.sinaimg.cn/large/67dd7669gy1fm4zx66hhmj20hf0auwi4.jpg" alt=""></p>
<p><strong>MVC</strong> 几乎是构建 Cocoa 的基石，也是最广泛应用的设计模式。它把对象根据其在应用程序中的作用划分为三类并鼓励依此划分代码区域：</p>
<ul>
<li>model：代表数据结构</li>
<li>view：用来可视化数据结构，或负责与用户的交互</li>
<li>controller：协调 model 和 view，从 model 拿到数据并用 view 进行显示，或者收听通知并处理数据等</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/67dd7669gy1fm4zwa3lghj20qz0d3q4g.jpg" alt=""></p>
<p>MVC 其实并不是一种单一的设计模式，而是许多设计模式的组合。例如，controller 可以视为 controller 和 view 的 <strong>Mediator</strong> 并应用了 <strong>Strategy</strong>，view 的结构是 <strong>Composite</strong>，view 和 controller 的 target-action 模式应用了 <strong>Command</strong>，controller 通过 <strong>Observer</strong> 接收 model 发生变化的通知。</p>
<h2 id="Cocoa-Touch-中最常见的两种模式"><a href="#Cocoa-Touch-中最常见的两种模式" class="headerlink" title="Cocoa Touch 中最常见的两种模式"></a>Cocoa Touch 中最常见的两种模式</h2><h3 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h3><p>Delegation 并不属于 GoF 提出的 23 种设计模式中的一种，但是在 Cocoa Touch 中很常见，一般有两种：</p>
<ol>
<li><p>view 和 controller 沟通的方式</p>
<p> view 的编程方式一般是 generic 的，因此怎么显示 view 或得到显示 view 需要的数据源一般通过询问它的 delegate 完成。通常情况下会将 controller 作为 view 的 delegate（或 data source），例如：</p>
<ul>
<li><code>UITableView</code></li>
<li><code>UITextField</code></li>
<li><code>UIGestureRecognizer</code></li>
</ul>
</li>
<li><p>其他对象之间的交互</p>
<p> 可以用于任何「不关心对方是什么类型，只要可以作为我的 delegate 能帮我完成一些特定任务」的场合。</p>
</li>
</ol>
<p>这些「特定任务」通过协议来规定，因此 Delegation 是基于协议的。</p>
<p>虽然 Delegation 不是 GoF 提出的一种，但也间接地实现了一些经典的设计模式，例如 <strong>Adapter</strong>，其含义为将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。类图如下</p>
<p><img src="http://ww1.sinaimg.cn/large/67dd7669gy1fmbxvw55wbj20u60cntbt.jpg" alt=""></p>
<p>典型的 Adapter 模式是会对 <code>Adaptee</code> 类构造一个 wrapper 类也就是 <code>Adapter</code>，并在 <code>Adapter</code> 中实现客户希望的另一个接口。Delegation 没有对类进行封装，但是间接实现了让接口不兼容的类一起工作的目的。</p>
<p>其他用 Delegation 实现的设计模式将在下文提到。</p>
<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>Observer 模式定义了对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。本质上是一种「发布-订阅」模型，使得对象和它的观察者之间解耦，可以在不知道彼此的情况下交流。其类图如下</p>
<p><img src="http://ww1.sinaimg.cn/large/67dd7669gy1fmby2fsfk2j20y10er44r.jpg" alt=""></p>
<p>在  Cocoa Touch 中有两种实现方式：</p>
<ol>
<li><p>Notification</p>
<p> Notification 机制实现了一对多的消息广播。对象可以向 notification center 注册成为某具体通知的 observer，这样当有其他对象发布了该通知时，notification center 就会通知 observer 对象。    </p>
<p> 具体通知例如 <code>UIKeyboardWillShow</code>（键盘将弹出，这时 UI 可以相应做出变化），<code>UIApplicationDidEnterBackground</code>（app 进入后台，可以迅速保存一些当前数据）等等系统通知，或者一些自定义通知。</p>
</li>
<li><p>Key-Value Observing (KVO)</p>
<p> KVO 主要用来观察其他对象属性的变化。尤其在 MVC 模式中，可以使 view 和 model 的变化保持同步（通过 controller）。KVO 和 Notification 的区别在于它不需要 notification center，而是直接将变化告知了 observer。Notification 更多地应用于系统通知。</p>
</li>
</ol>
<h2 id="经典设计模式在-iOS-中的应用"><a href="#经典设计模式在-iOS-中的应用" class="headerlink" title="经典设计模式在 iOS 中的应用"></a>经典设计模式在 iOS 中的应用</h2><h3 id="Creational"><a href="#Creational" class="headerlink" title="Creational"></a>Creational</h3><h4 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h4><p>使用原型实例指定创建对象的种类，并通过复制这个原型创建新的对象。</p>
<p>这种模式很简单，指无需手动创建、通过复制就可以制造同一类型的多个实例。</p>
<p>在 Cocoa Touch 中的一个典型应用是 <code>UITableViewCell</code>：</p>
<blockquote>
<p>Use dynamic prototypes to design one cell and then use it as the template for other cells in the table. Use a dynamic prototype when multiple cells in a table should use the same layout to display information.</p>
</blockquote>
<p>要通过原型复制得到新的对象，需要实现深复制协议。对于 <code>NSObject</code> 的子类，需要实现 <code>NSCopying</code> 协议及其方法 <code>- (id)copyWithZone:(NSZone *)zone</code>。通过调用实例方法 <code>-(id)copy</code> 进行复制，该方法默认会调用 <code>[self copyWithZone:nil]</code>。</p>
<h4 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h4><p>单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p><img src="http://ww1.sinaimg.cn/large/67dd7669gy1fmd3oc05bxj20n8084tb0.jpg" alt=""></p>
<p>在 Cocoa Touch 中的应用有两种情况：</p>
<ol>
<li><p>单一资源</p>
<p> 例如 CoreLocation 中的 <code>CLLocationManager</code> 类，定义了对 GPS 设备所提供服务的单一访问点。又如 <code>UIScreen.main</code> 等。</p>
</li>
<li><p>统一管理</p>
<p> 例如 <code>FileManager.default</code>、或常见的 MVC-N 模式中的 N（NetworkManager）等。</p>
</li>
</ol>
<p>典型的创建单例的代码如下：</p>
<p><img src="http://ww1.sinaimg.cn/large/67dd7669gy1fmd44tr6e4j20pq07omyi.jpg" alt=""></p>
<p>这里，<code>sharedInstance</code> 是 type property，<code>static</code> 保证了它只初始化一次且线程安全。同时将 <code>init</code> 方法声明为 <code>private</code> 保证了不能在类外创建该类的对象。</p>
<h4 id="Abstract-Factory"><a href="#Abstract-Factory" class="headerlink" title="Abstract Factory"></a>Abstract Factory</h4><p>抽象工厂模式提供了用于创建一系列相互关联的对象的接口，而无须指定它们具体的类。将客户端和具体类型解耦。类图如下</p>
<p><img src="http://ww1.sinaimg.cn/large/67dd7669gy1fmd4ewls47j21480h7wme.jpg" alt=""></p>
<p>在 Cocoa Touch 中有个很重要的应用就是 Class Cluster（类簇）。它封装了一系列私有具体子类，提供了一个公有抽象超类的接口。抽象超类声明了一系列创建私有子类对象的方法，再根据不同的方法动态选择合适的具体子类类型。 </p>
<blockquote>
<p>Class clusters in Cocoa can generate only objects whose storage of data can vary depending on circumstances. </p>
</blockquote>
<p>在 Foundation 框架中，<code>NSNumber</code>、<code>NSString</code>、<code>NSData</code>、<code>NSDictionary</code>、<code>NSSet</code> 和 <code>NSArray</code> 以及它们的 mutable 版本都是基于类簇实现的。</p>
<p>拿 <code>NSNumber</code> 举例来说，该抽象超类声明了一系列创建对象的方法：</p>
<p><img src="http://ww1.sinaimg.cn/large/67dd7669gy1fmd4y54wx1j20cp07dwfl.jpg" alt=""></p>
<p>不同方法返回的对象可能属于不同的私有子类，其具体类型对调用者不可见。</p>
<blockquote>
<p>With class clusters there is a trade-off between simplicity and extensibility. </p>
</blockquote>
<p>类簇简化了类的接口，使得学习和使用类变得更容易。然而，自定义抽象超类的子类也变得复杂。</p>
<h3 id="Structural"><a href="#Structural" class="headerlink" title="Structural"></a>Structural</h3><h4 id="Decorator"><a href="#Decorator" class="headerlink" title="Decorator"></a>Decorator</h4><p>用于动态地给对象增加一些额外的职责。这种方式比生成子类的实现更为灵活。类图如下</p>
<p><img src="http://ww1.sinaimg.cn/large/67dd7669gy1fmjnpz0rk1j20yr0kx0xk.jpg" alt=""></p>
<p>装饰通过包装类的对象来扩展其行为，诠释了设计原则：</p>
<blockquote>
<p>Classes should be open to extension but closed to modification.</p>
</blockquote>
<p>在 Cocoa Touch 中应用了这一设计原则的类例如 <code>UIScrollView</code> 和 <code>UIDatePicker</code>，它们是复合视图，结合了其他类的简单视图对象并协调其交互。</p>
<p>另外，基于这一设计模式，有两种典型的实现方式：</p>
<ol>
<li><p>Category</p>
<p> 它是Objective-C语言的特性，可以动态向类或结构添加额外的方法，而无需子类化。运行时，通过这种方式添加的方法与类中定义的原始方法没有任何差别。因此这种方式添加的方法也会被子类继承。尤其好的一点是，它可以用于看不到源码的类。需要注意的是：</p>
<ul>
<li>不能向类添加实例变量</li>
<li><p>如果添加的方法覆盖了类中已有的方法，运行时行为将不可预测</p>
<p>Category 并没有严格地实现装饰模式，没有包装类的对象，也没有动态扩展类而是一种编译时的特性。它通过其他方式实现了装饰模式的目的。</p>
</li>
</ul>
</li>
<li><p>Delegation</p>
<p> 前文有介绍过，同样地，它也不是装饰模式的严格实现，没有对类的对象进行包装，而是让类将一些指定行为动态交给类的 delegate 去完成。除了 delegation 定义的方法，没有其他共享的接口。</p>
</li>
</ol>
<h4 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h4><p>组合模式将对象组合成树形结构来表示「部分-整体」的层次结构，统一了访问单个对象和组合对象的接口。</p>
<p><img src="http://ww1.sinaimg.cn/large/67dd7669gy1fmjqa3o9gxj20z00i2gqt.jpg" alt=""></p>
<p>在 Cocoa Touch 中典型的应用就是 View Hierarchy：</p>
<p><img src="http://ww1.sinaimg.cn/large/67dd7669gy1fmjqbgc17vj20pc0e0jt3.jpg" alt=""></p>
<p>view 可以添加其他 view 作为 subview，同时这些 subview 又可以作为其他 view 的 superview。每个 view 都只有一个 superview，可以有任意数量的 subview。这样就形成了树状结构。这种结构的好处是方便遍历：</p>
<ul>
<li><p>drawing</p>
<p>  当 window 需要显示时，superview 会在 subview 之前进行 render。当有消息发送给 view，消息会进一步发送给 subview。这样 view hierarchy 就可以当做一个整体的 view 来对待。</p>
</li>
<li><p>event handling</p>
<p>  用于形成 responder chain 来处理各种事件，详见 <strong>Chain of Responsibility</strong> 模式。</p>
</li>
</ul>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p>用于控制对其他对象的访问。</p>
<p><img src="http://ww1.sinaimg.cn/large/67dd7669gy1fmjrc7mhioj20w20do422.jpg" alt=""></p>
<p>Cocoa Touch 中有个 <code>NSProxy</code> 类，用来作其他对象的代理。有多种用途：</p>
<ul>
<li><p>lazy instantiation</p>
<p>  proxy 对象作为占位符，实现昂贵资源的懒加载。例如 Mail app 中，较大的附件资源通常先显示为占位符，当用户点击之后再去真正地下载附件。</p>
</li>
<li><p>method forwarding</p>
<p>  proxy 对象将消息转发给其代理的对象，可以用这种机制类似地实现多重继承。</p>
</li>
<li><p>sentry objects for security</p>
<p>  为了保证安全性，先由 proxy 对象检查访问权限。</p>
</li>
</ul>
<h4 id="Facade"><a href="#Facade" class="headerlink" title="Facade"></a>Facade</h4><p>外观模式为子系统中的一组接口提供一个统一的高层接口，让子系统更易于使用。</p>
<p><img src="http://ww1.sinaimg.cn/large/67dd7669gy1fmjrswakqlj20xx0e0wht.jpg" alt=""></p>
<p>在 Cocoa Touch 中的一个例子是 <code>UIImage</code>，它提供了一个统一的接口来加载图片，将图片格式的细节隐藏起来。</p>
<h3 id="Behavioral"><a href="#Behavioral" class="headerlink" title="Behavioral"></a>Behavioral</h3><h4 id="Chain-of-Responsibility"><a href="#Chain-of-Responsibility" class="headerlink" title="Chain of Responsibility"></a>Chain of Responsibility</h4><p>责任链模式将多个对象连成一条链，并沿着这条链传递请求，直到有一个对象响应为止。使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间发生耦合。</p>
<p><img src="http://ww1.sinaimg.cn/large/67dd7669gy1fmjs5uugz7j20n50eiwgk.jpg" alt=""></p>
<p>在 Cocoa Touch 中的典型应用是 responder chain（响应链）。下图是含 label、button 等的例子及其默认的响应链：</p>
<p><img src="http://ww1.sinaimg.cn/large/67dd7669gy1fmjs7k65ppj20ux0ip0uv.jpg" alt=""></p>
<p>当 app 接收了某种 event，UIKit 会自动将该 event 传给 first responder。如果它不能处理 event，会把 event 发送给其 next responder。未处理的 event 会沿着响应链传递，直到某个 responder 可以处理为止。</p>
<p>细节可以参考官方文档 <a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/understanding_event_handling_responders_and_the_responder_chain" target="_blank" rel="noopener">Understanding Event Handling, Responders, and the Responder Chain</a>。</p>
<h4 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h4><p>命令模式将一个请求封装为一个对象，对请求排队或者记录请求日志，支持可撤销的操作。它将提出请求的对象与接受并执行请求的对象解耦。类图如下</p>
<p><img src="http://ww1.sinaimg.cn/large/67dd7669gy1fmjt9ffizlj211s0hyq6d.jpg" alt=""></p>
<p>用 <code>NSInvocation</code> 类来封装 Objective-C 的消息（也包括目标对象和参数等）。在 Cocoa Touch 中有两个应用：</p>
<ul>
<li><p>Target-Action 机制</p>
<p>  在这种机制下，一个 control 对象（例如 button、slider 或 tex field 等）会向其 target 发送封装好的 action 消息。target 接收后将对消息进行处理。</p>
</li>
<li><p><code>NSUndoManager</code> 类</p>
<p>  用于撤销操作和恢复操作。它管理了一个撤销栈和恢复栈，当命令执行后，就将其 push 到撤销栈。如果需要撤销，则从撤销栈中 pop 一个命令，并 push 到恢复栈。如果需要恢复，就从恢复栈中 pop 一个命令，再 push 到撤销栈。两个栈配合使用，可以方便地执行撤销和恢复操作。</p>
</li>
</ul>
<h4 id="Mediator"><a href="#Mediator" class="headerlink" title="Mediator"></a>Mediator</h4><p>用一个对象（中介者）来封装一系列对象的交互方式，使各对象不需要显式地相互引用从而解耦，且可以独立地改变它们之间的交互。</p>
<p><img src="http://ww1.sinaimg.cn/large/67dd7669gy1fmjty524n9j20yo0c7jv6.jpg" alt=""></p>
<p>典型应用就是 MVC 模式中的 controller。在 Cocoa Touch 中，负责这一角色的是 <code>UIViewController</code>，来协调 model 和 view 的交互。 同样地，对于多个 view controller，也有 <code>UINavigationController</code> 和 <code>UITabBarController</code> 来作为其中介者。</p>
<p><img src="http://ww1.sinaimg.cn/large/67dd7669gy1fmju6ps10ij20p70k1jw7.jpg" alt=""></p>
<h4 id="Memento"><a href="#Memento" class="headerlink" title="Memento"></a>Memento</h4><p>备忘录模式用于保存数据和恢复数据。在不破坏封装的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态，方便以后将该对象恢复到原先保存的状态。类图如下</p>
<p><img src="http://ww1.sinaimg.cn/large/67dd7669gy1fmju8ky2rkj21340czwix.jpg" alt=""></p>
<p>在 Cocoa Touch 中的应用包括：</p>
<ul>
<li><p>State Restoration </p>
<p>  当 app 退出时，可以通过保存当前 state 以在下次打开该 app 时恢复到退出前的状态。</p>
</li>
<li><p>Archiving</p>
<p>  归档操作将对象类型及其属性保存为一个归档文件，可以保存在文件系统中或进行网络传输。通常需要对 MVC 中的 model 进行 encode 归档，再从该归档 decode 读取 model。 可以分别利用 <code>NSKeyedArchiver</code> 和 <code>NSKeyedUnarchiver</code>，并遵从 <code>NSCoding</code> 协议。 </p>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>最后，附上参考文献：</p>
<ol>
<li>官方文档 <a href="https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaDesignPatterns/CocoaDesignPatterns.html#//apple_ref/doc/uid/TP40002974-CH6-SW6" target="_blank" rel="noopener">Cocoa Design Patterns</a></li>
<li>设计模式的书（本文截图出处）<a href="https://link.springer.com/chapter/10.1007/978-1-4302-3331-2_11" target="_blank" rel="noopener">Pro Objective-C Design Patterns for iOS</a></li>
<li>开源项目 <a href="https://github.com/ochococo/Design-Patterns-In-Swift" target="_blank" rel="noopener">Design-Patterns-In-Swift</a></li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
            <a href="/tags/design-pattern/" rel="tag"># design pattern</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/27/Use-Instruments-to-Find-Memory-Leak-in-iOS/" rel="next" title="iOS 开发之用 Instruments 寻找内存泄露">
                <i class="fa fa-chevron-left"></i> iOS 开发之用 Instruments 寻找内存泄露
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/29/GPUImage-source-code-1-CVOpenGLESTextureCache/" rel="prev" title="GPUImage源码阅读（一）：CVOpenGLESTextureCache 理解">
                GPUImage源码阅读（一）：CVOpenGLESTextureCache 理解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">子轶</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yzlyty" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://weibo.com/yitianyu" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#当我们谈论设计模式的时候，我们在谈什么？"><span class="nav-number">1.</span> <span class="nav-text">当我们谈论设计模式的时候，我们在谈什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVC——设计模式之王"><span class="nav-number">2.</span> <span class="nav-text">MVC——设计模式之王</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cocoa-Touch-中最常见的两种模式"><span class="nav-number">3.</span> <span class="nav-text">Cocoa Touch 中最常见的两种模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Delegation"><span class="nav-number">3.1.</span> <span class="nav-text">Delegation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Observer"><span class="nav-number">3.2.</span> <span class="nav-text">Observer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#经典设计模式在-iOS-中的应用"><span class="nav-number">4.</span> <span class="nav-text">经典设计模式在 iOS 中的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Creational"><span class="nav-number">4.1.</span> <span class="nav-text">Creational</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Prototype"><span class="nav-number">4.1.1.</span> <span class="nav-text">Prototype</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Singleton"><span class="nav-number">4.1.2.</span> <span class="nav-text">Singleton</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Abstract-Factory"><span class="nav-number">4.1.3.</span> <span class="nav-text">Abstract Factory</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Structural"><span class="nav-number">4.2.</span> <span class="nav-text">Structural</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Decorator"><span class="nav-number">4.2.1.</span> <span class="nav-text">Decorator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Composite"><span class="nav-number">4.2.2.</span> <span class="nav-text">Composite</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Proxy"><span class="nav-number">4.2.3.</span> <span class="nav-text">Proxy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Facade"><span class="nav-number">4.2.4.</span> <span class="nav-text">Facade</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Behavioral"><span class="nav-number">4.3.</span> <span class="nav-text">Behavioral</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Chain-of-Responsibility"><span class="nav-number">4.3.1.</span> <span class="nav-text">Chain of Responsibility</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Command"><span class="nav-number">4.3.2.</span> <span class="nav-text">Command</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mediator"><span class="nav-number">4.3.3.</span> <span class="nav-text">Mediator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Memento"><span class="nav-number">4.3.4.</span> <span class="nav-text">Memento</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献"><span class="nav-number">5.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">子轶</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
